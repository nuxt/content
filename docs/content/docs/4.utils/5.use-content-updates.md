---
title: useContentUpdates
description: The useContentUpdates composable detects new Nuxt Content bundles and lets you trigger a controlled refresh in your app.
---

## Usage

`useContentUpdates` is auto-imported like the other Nuxt Content utilities. Call it inside your components to get a reactive flag that indicates whether fresh content is available, plus helpers to check the current status or force a reload when you decide to surface a button.

```vue [components/ContentUpdateBanner.vue]
<script setup lang="ts">
const {
  hasUpdate,
  isChecking,
  checkForContentUpdate,
  refreshContent,
} = useContentUpdates()

const onCheck = async () => {
  await checkForContentUpdate()
}

const onRefresh = () => {
  refreshContent('user-refresh')
}
</script>

<template>
  <div>
    <button :disabled="isChecking" @click="onCheck">
      {{ isChecking ? 'Checking…' : 'Check for content updates' }}
    </button>
    <button v-if="hasUpdate" @click="onRefresh">
      New content available — reload
    </button>
  </div>
</template>
```

::tip
`checkForContentUpdate()` performs a lightweight fetch to `/__nuxt_content/manifest.json` and compares versions with the bundle the user is currently running. Nothing is reloaded automatically—you are in control of when to call `refreshContent()`.
::

## Type

```ts
type ContentUpdatePayload = {
  currentVersion: Ref<string>
  latestVersion: Ref<string | null>
  hasUpdate: Ref<boolean>
  isChecking: Ref<boolean>
  lastChecked: Ref<number | null>
  error: Ref<string | null>
  checkForContentUpdate(): Promise<boolean>
  refreshContent(reason?: string): Promise<void>
}

function useContentUpdates(): ContentUpdatePayload
```

## API

### `checkForContentUpdate()`

Checks whether a newer manifest version exists.

- Returns: `Promise<boolean>` — `true` when a newer version was detected.
- Side effects: updates the reactive state (`latestVersion`, `hasUpdate`, `lastChecked`, `error`).

### `refreshContent(reason?: string)`

Calls the built-in `forceClientRefresh()` helper to clear cached dumps and reload the page.

- `reason`: Optional string for diagnostics (appears in reload telemetry).
- Returns: `Promise<void>`

## Example

Provide a global snackbar/banner when a newer bundle is published:

```vue [app.vue]
<script setup lang="ts">
const { hasUpdate, checkForContentUpdate, refreshContent } = useContentUpdates()

onMounted(() => {
  const interval = window.setInterval(() => {
    checkForContentUpdate()
  }, 60_000)
  onBeforeUnmount(() => window.clearInterval(interval))
})
</script>

<template>
  <NuxtPage />
  <div v-if="hasUpdate" class="update-banner">
    <span>Fresh docs are ready.</span>
    <button @click="refreshContent()">Reload</button>
  </div>
</template>
```

Because Nuxt Content does not enforce auto-refreshes, this pattern lets you keep control over the UX (show only when it makes sense, batch by route, etc.).
